<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Canvas with Background Image</title>
    <style>
        body,
        html {
            height: 100%;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #canvas-container {
            position: relative;
        }
        
        canvas {
            border: 1px solid #000;
        }
        
        #container {
            display: flex;
            flex-direction: column;
            align-items: left;
            justify-content: center;
            height: 100vh;
        }
        
        .input-container {
            margin: 10px;
        }
        /* Styling for the checkboxes */
        
        .fancy-checkbox {
            display: none;
        }
        
        .fancy-checkbox+label:before {
            content: "";
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #000;
            margin-right: 5px;
            vertical-align: middle;
            cursor: pointer;
        }
        
        .fancy-checkbox:checked+label:before {
            background-color: #000;
        }
        /* Optional styling for the labels */
        
        label {
            font-family: Arial, sans-serif;
        }
    </style>
    <script src="output.js"></script>
    <script src="hungarian.js"></script>
</head>

<body>
    <div id="container">
        <div class="input-container">
            <input type="checkbox" class="fancy-checkbox" id="checkbox0" checked>
            <label for="checkbox0">Draw Drones</label>
        </div>
        <div class="input-container">
            <input type="checkbox" class="fancy-checkbox" id="checkbox1" checked>
            <label for="checkbox1">Draw Drone Directions</label>
        </div>
        <div class="input-container">
            <input type="checkbox" class="fancy-checkbox" id="checkbox2" checked>
            <label for="checkbox2">Disable History</label>
        </div>
        <div class="input-container">
            <input type="checkbox" class="fancy-checkbox" id="checkbox3" checked>
            <label for="checkbox3">Draw Optimal Locations</label>
        </div>
        <div class="input-container">
            <input type="checkbox" class="fancy-checkbox" id="checkbox4">
            <label for="checkbox4">Draw Gradient Descent</label>
        </div>
        <div class="input-container">
            <input type="checkbox" class="fancy-checkbox" id="checkbox5">
            <label for="checkbox5">Animate</label>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="myCanvas"></canvas>
        <img src="BPmap.jpeg" id="background-image" style="display: none;">
    </div>
    <script>
        var gif_index = 0;
        const imageWidth = globalData[gif_index].imageSize;
        const parseWidth = globalData[gif_index].width;
        const scale = Math.floor(imageWidth / parseWidth);
        const radius = globalData[gif_index].radius;
        const radiusWidth = radius * scale;

        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');

        const backgroundImage = document.getElementById('background-image');
        backgroundImage.src = globalData[gif_index].imageName; // Replace with your image path
        // Wait for the image to load before setting canvas size
        backgroundImage.onload = drawBackground;

        var current_index = globalData[gif_index].coverage.length - 1;
        var runOnce = false;

        function drawBackground() {
            backgroundImage.src = globalData[gif_index].imageName;
            canvas.width = backgroundImage.width;
            canvas.height = backgroundImage.height;
            ctx.drawImage(backgroundImage, 0, 0);

            if (checkCheckboxByIndex(3)) {
                drawCircles(current_index);
            }

            ctx.font = '20px Arial';
            ctx.fillStyle = 'black';

            ctx.fillText(globalData[gif_index].coverage[current_index], 50, 50);
            ctx.fillText(globalData[gif_index].imageName, 50, 30);
            ctx.fillText(current_index, 10, 30);

            //drones
            //drawDrones();
            if (!runOnce) {
                runOnce = true;
                // Start the animation
                animate();
            }
        };

        function drawDottedLine(startX, startY, endX, endY, colorcurrent_index) {
            // Convert the colorcurrent_index into a color using a formula
            const red = (colorcurrent_index * 70) % 256 * .7;
            const green = (colorcurrent_index * 50) % 256 * .7;
            const blue = (colorcurrent_index * 30) % 256 * .7;

            const color = `rgb(${red}, ${green}, ${blue})`;

            ctx.strokeStyle = color;
            ctx.lineWidth = 5; // Set line width to make it bolder
            ctx.setLineDash([8, 8]);
            ctx.beginPath();
            ctx.moveTo(startX, startY); // Starting point coordinates (startX, startY)
            ctx.lineTo(endX, endY); // Ending point coordinates (endX, endY)
            ctx.stroke();
        }

        // Function to draw circles on the canvas
        function drawCircles(current_index) {
            for (let i = 0; i < globalData[gif_index].positions[current_index].length; i++) {
                const x = (globalData[gif_index].positions[current_index][i][1]) * scale;
                const y = globalData[gif_index].positions[current_index][i][0] * scale;

                ctx.beginPath();
                ctx.arc(x, y, radiusWidth, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(87, 187, 229, 0.55)"; // rgba(255, 165, 0, 1)
                ctx.fill();
                ctx.closePath();
                ctx.font = '15px Arial';
                ctx.fillStyle = 'black';
                ctx.fillText(globalData[gif_index].individualHistory[current_index][i], x - radiusWidth / 1.5, y + 20);

                if (checkCheckboxByIndex(4)) {
                    for (let j = 1; j <= current_index; j++) {
                        drawDottedLine((globalData[gif_index].positions[j - 1][i][1]) * scale, globalData[gif_index].positions[j - 1][i][0] * scale,
                            (globalData[gif_index].positions[j][i][1]) * scale, globalData[gif_index].positions[j][i][0] * scale, i);
                    }
                }
            }
        }

        // Function to handle keydown events
        function handleKeyDown(event) {
            if (event.key === "ArrowUp" && !checkCheckboxByIndex(2)) {
                if (current_index < globalData[gif_index].positions.length - 1) {
                    current_index++; // Increase the variable when the up arrow key is pressed
                } else {
                    current_index = 0;
                }
                console.log("Increased: " + current_index);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBackground();
            } else if (event.key === "ArrowDown" && !checkCheckboxByIndex(2)) {
                if (current_index > 0) {
                    current_index--; // Increase the variable when the up arrow key is pressed
                } else {
                    current_index = globalData[gif_index].positions.length - 1;
                }
                console.log("Decreased: " + current_index);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBackground();
            }
            if (event.key === "ArrowRight") {
                if (gif_index < globalData.length - 1) {
                    gif_index++; // Increase the variable when the up arrow key is pressed
                } else {
                    gif_index = 0;
                }
                current_index = globalData[gif_index].coverage.length - 1;
                console.log("Frame Increased: " + gif_index);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBackground();
            } else if (event.key === "ArrowLeft") {
                if (gif_index > 0) {
                    gif_index--; // Increase the variable when the up arrow key is pressed
                } else {
                    gif_index = globalData.length - 1;
                }
                current_index = globalData[gif_index].coverage.length - 1;
                console.log("Frame Decreased: " + gif_index);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBackground();
            }
        }

        // hungarian
        const droneLocations = [];

        function randomLocations(n) {
            for (let i = 0; i < n; i++) {
                let coord = [];
                coord.push(Math.floor(Math.random() * globalData[gif_index].width), Math.floor(Math.random() * globalData[gif_index].width));
                droneLocations.push(coord);
            }
        }

        // let n = 3;
        // let Arr = [1500, 4000, 4500, 2000, 6000, 3500, 2000, 4000, 2500];
        let n = globalData[0].numDrones;
        randomLocations(n);
        let optimalPos = globalData[gif_index].positions[current_index];


        let optimals = [];


        // Function to draw circles on the canvas
        function drawDrones() {
            let weights = [];
            //let lastIndex = globalData[gif_index].positions.length - 1;

            for (let drones = 0; drones < n; drones++) {
                for (let holeIndex = 0; holeIndex < n; holeIndex++) {
                    let xDiff = globalData[gif_index].positions[current_index][holeIndex][1] - droneLocations[drones][0];
                    let yDiff = globalData[gif_index].positions[current_index][holeIndex][0] - droneLocations[drones][1];
                    let thisWeight = Math.pow(xDiff, 2) + Math.pow(yDiff, 2);
                    weights.push(thisWeight);
                }
            }
            let ob = new Solution();
            let answer = ob.assignmentProblem(weights, n)[0];
            optimals = ob.assignmentProblem(weights, n)[1];
            for (let i = 0; i < droneLocations.length; i++) {
                const x = droneLocations[i][0] * scale;
                const y = droneLocations[i][1] * scale;

                ctx.beginPath();
                ctx.arc(x, y, radiusWidth, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(23, 122, 6, 0.61)"; // rgba(255, 165, 0, 1)
                ctx.fill();
                ctx.closePath();

                if (checkCheckboxByIndex(1)) {
                    ctx.font = '15px Arial';
                    ctx.fillStyle = 'black';
                    ctx.fillText("Drone " + i, x - radiusWidth / 4, y - 20);

                    drawDottedLine(x, y, globalData[gif_index].positions[current_index][optimals[i]][1] * scale,
                        globalData[gif_index].positions[current_index][optimals[i]][0] * scale, i);
                }
                ctx.font = '20px Arial';
                ctx.fillStyle = 'black';

                ctx.fillText("Travel: " + -1 * answer, 50, 70);
            }
        }

        const moveSize = 0.2;

        function moveDroneTowardsTarget(i) {
            // Calculate the distance between current and target positions
            let xDiff = globalData[gif_index].positions[current_index][optimals[i]][1] - droneLocations[i][0];
            let yDiff = globalData[gif_index].positions[current_index][optimals[i]][0] - droneLocations[i][1];
            const distance = Math.sqrt(xDiff * xDiff + yDiff * yDiff);

            // Move the drone if it's not at the target position yet
            if (distance > moveSize) {
                // Calculate the normalized direction towards the target
                const directionX = xDiff / distance;
                const directionY = yDiff / distance;

                // Move the drone towards the target by step size
                droneLocations[i][0] += directionX * moveSize;
                droneLocations[i][1] += directionY * moveSize;
            } else {
                // Drone reached the target, stop moving
                droneLocations[i][0] = globalData[gif_index].positions[current_index][optimals[i]][1];
                droneLocations[i][1] = globalData[gif_index].positions[current_index][optimals[i]][0];
            }
        }

        function animate() {
            if (checkCheckboxByIndex(0)) {
                drawDrones();
                for (let i = 0; i < n; i++) {
                    moveDroneTowardsTarget(i);
                }
            }
            // Request next animation frame
            requestAnimationFrame(animate);
        }

        // Event listener for keydown events
        window.addEventListener("keydown", handleKeyDown);

        // Function to check the checkbox at a specific index
        function checkCheckboxByIndex(index) {
            const checkboxes = document.querySelectorAll('.fancy-checkbox');

            if (index >= 0 && index < checkboxes.length) {
                return checkboxes[index].checked;
            }
        }

        // Function to handle new inputs
        function handleNewInput(event) {
            // You can perform any action here when a new input occurs
            console.log(`New input detected from checkbox ${event.target.id}`);
            drawBackground();
        }

        // Attach event listener to each checkbox
        const checkboxes = document.querySelectorAll('.fancy-checkbox');
        checkboxes.forEach(checkbox => {
            checkbox.addEventListener('change', handleNewInput);
        });

        // Function to simulate pressing the right arrow key
        function pressRightArrowKey() {
            const event = new KeyboardEvent('keydown', {
                key: 'ArrowRight',
                keyCode: 39,
                which: 39,
                code: 'ArrowRight',
                keyIdentifier: 'Right'
            });

            // Dispatch the event
            window.dispatchEvent(event);
        }
        // Function to be called every second
        function nextSlide() {
            if (checkCheckboxByIndex(5)) {
                pressRightArrowKey();
            }
        }

        // Call the function every second (1000 milliseconds)
        setInterval(nextSlide, 1000);
    </script>
</body>

</html>