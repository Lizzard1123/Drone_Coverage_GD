<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Canvas with Background Image</title>
    <style>
        body,
        html {
            height: 100%;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #canvas-container {
            position: relative;
        }
        
        canvas {
            border: 1px solid #000;
        }
    </style>
    <script src="output.js"></script>
    <script src="hungarian.js"></script>
</head>

<body>
    <div id="canvas-container">
        <canvas id="myCanvas"></canvas>
        <img src="BPmap.jpeg" id="background-image" style="display: none;">
    </div>
    <script>
        var gif_index = 0;
        const imageWidth = globalData[gif_index].imageSize;
        const parseWidth = globalData[gif_index].width;
        const scale = Math.floor(imageWidth / parseWidth);
        const radius = globalData[gif_index].radius;
        const radiusWidth = radius * scale;

        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');

        const backgroundImage = document.getElementById('background-image');
        backgroundImage.src = globalData[gif_index].imageName; // Replace with your image path
        // Wait for the image to load before setting canvas size
        backgroundImage.onload = drawBackground;

        var current_index = 0;
        var runOnce = false;

        function drawBackground() {
            backgroundImage.src = globalData[gif_index].imageName;
            canvas.width = backgroundImage.width;
            canvas.height = backgroundImage.height;
            ctx.drawImage(backgroundImage, 0, 0);

            drawCircles(current_index);
            ctx.font = '20px Arial';
            ctx.fillStyle = 'black';

            ctx.fillText(globalData[gif_index].coverage[current_index], 50, 50);
            ctx.fillText(globalData[gif_index].imageName, 50, 30);

            //drones
            //drawDrones();
            if (!runOnce) {
                runOnce = true;
                // Start the animation
                animate();
            }
        };

        function drawDottedLine(startX, startY, endX, endY, colorcurrent_index) {
            // Convert the colorcurrent_index into a color using a formula
            const red = (colorcurrent_index * 70) % 256 * .7;
            const green = (colorcurrent_index * 50) % 256 * .7;
            const blue = (colorcurrent_index * 30) % 256 * .7;

            const color = `rgb(${red}, ${green}, ${blue})`;

            ctx.strokeStyle = color;
            ctx.lineWidth = 5; // Set line width to make it bolder
            ctx.setLineDash([8, 8]);
            ctx.beginPath();
            ctx.moveTo(startX, startY); // Starting point coordinates (startX, startY)
            ctx.lineTo(endX, endY); // Ending point coordinates (endX, endY)
            ctx.stroke();
        }

        // Function to draw circles on the canvas
        function drawCircles(current_index) {
            for (let i = 0; i < globalData[gif_index].positions[current_index].length; i++) {
                const x = (globalData[gif_index].positions[current_index][i][1]) * scale;
                const y = globalData[gif_index].positions[current_index][i][0] * scale;

                ctx.beginPath();
                ctx.arc(x, y, radiusWidth, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(87, 187, 229, 0.55)"; // rgba(255, 165, 0, 1)
                ctx.fill();
                ctx.closePath();
                ctx.font = '15px Arial';
                ctx.fillStyle = 'black';
                ctx.fillText(globalData[gif_index].individualHistory[current_index][i], x - radiusWidth / 1.5, y + 20);

                for (let j = 1; j <= current_index; j++) {
                    //drawDottedLine((globalData[gif_index].positions[j - 1][i][1]) * scale, globalData[gif_index].positions[j - 1][i][0] * scale,
                    //(globalData[gif_index].positions[j][i][1]) * scale, globalData[gif_index].positions[j][i][0] * scale, i);
                }
            }
        }

        // Function to handle keydown events
        function handleKeyDown(event) {
            if (event.key === "ArrowUp") {
                if (current_index < globalData[gif_index].positions.length - 1) {
                    current_index++; // Increase the variable when the up arrow key is pressed
                } else {
                    current_index = 0;
                }
                console.log("Increased: " + current_index);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBackground();
            } else if (event.key === "ArrowDown") {
                if (current_index > 0) {
                    current_index--; // Increase the variable when the up arrow key is pressed
                } else {
                    current_index = globalData[gif_index].positions.length - 1;
                }
                console.log("Decreased: " + current_index);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBackground();
            }
            if (event.key === "ArrowRight" && gif_index < globalData.length - 1) {
                gif_index++; // Increase the variable when the up arrow key is pressed
                current_index = globalData[gif_index].coverage.length - 1;
                console.log("Frame Increased: " + gif_index);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBackground();
            } else if (event.key === "ArrowLeft" && gif_index > 0) {
                gif_index--; // Decrease the variable when the down arrow key is pressed
                current_index = globalData[gif_index].coverage.length - 1;
                console.log("Frame Decreased: " + gif_index);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBackground();
            }
        }

        // hungarian
        const droneLocations = [];

        function randomLocations(n) {
            for (let i = 0; i < n; i++) {
                let coord = [];
                coord.push(Math.floor(Math.random() * globalData[gif_index].width), Math.floor(Math.random() * globalData[gif_index].width));
                droneLocations.push(coord);
            }
        }

        // let n = 3;
        // let Arr = [1500, 4000, 4500, 2000, 6000, 3500, 2000, 4000, 2500];
        let n = globalData[0].numDrones;
        randomLocations(n);
        let optimalPos = globalData[gif_index].positions[current_index];


        let optimals = [];


        // Function to draw circles on the canvas
        function drawDrones() {
            let weights = [];
            //let lastIndex = globalData[gif_index].positions.length - 1;

            for (let drones = 0; drones < n; drones++) {
                for (let holeIndex = 0; holeIndex < n; holeIndex++) {
                    let xDiff = globalData[gif_index].positions[current_index][holeIndex][1] - droneLocations[drones][0];
                    let yDiff = globalData[gif_index].positions[current_index][holeIndex][0] - droneLocations[drones][1];
                    let thisWeight = Math.pow(xDiff, 2) + Math.pow(yDiff, 2);
                    weights.push(thisWeight);
                }
            }
            let ob = new Solution();
            let answer = ob.assignmentProblem(weights, n)[0];
            optimals = ob.assignmentProblem(weights, n)[1];
            for (let i = 0; i < droneLocations.length; i++) {
                const x = droneLocations[i][0] * scale;
                const y = droneLocations[i][1] * scale;

                ctx.beginPath();
                ctx.arc(x, y, radiusWidth, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(23, 122, 6, 0.61)"; // rgba(255, 165, 0, 1)
                ctx.fill();
                ctx.closePath();
                ctx.font = '15px Arial';
                ctx.fillStyle = 'black';
                ctx.fillText("Drone " + i, x - radiusWidth / 4, y - 20);

                // for (let j = 1; j <= current_index; j++) {
                //     drawDottedLine((globalData[gif_index].positions[j - 1][i][1]) * scale, globalData[gif_index].positions[j - 1][i][0] * scale,
                //         (globalData[gif_index].positions[j][i][1]) * scale, globalData[gif_index].positions[j][i][0] * scale, i);
                // }
                drawDottedLine(x, y, globalData[gif_index].positions[current_index][optimals[i]][1] * scale,
                    globalData[gif_index].positions[current_index][optimals[i]][0] * scale, i);
                ctx.font = '20px Arial';
                ctx.fillStyle = 'black';

                ctx.fillText("Travel: " + -1 * answer, 50, 70);
            }
        }

        const moveSize = 0.2;

        function moveDroneTowardsTarget(i) {
            // Calculate the distance between current and target positions
            let xDiff = globalData[gif_index].positions[current_index][optimals[i]][1] - droneLocations[i][0];
            let yDiff = globalData[gif_index].positions[current_index][optimals[i]][0] - droneLocations[i][1];
            const distance = Math.sqrt(xDiff * xDiff + yDiff * yDiff);

            // Move the drone if it's not at the target position yet
            if (distance > moveSize) {
                // Calculate the normalized direction towards the target
                const directionX = xDiff / distance;
                const directionY = yDiff / distance;

                // Move the drone towards the target by step size
                droneLocations[i][0] += directionX * moveSize;
                droneLocations[i][1] += directionY * moveSize;
            } else {
                // Drone reached the target, stop moving
                droneLocations[i][0] = globalData[gif_index].positions[current_index][optimals[i]][1];
                droneLocations[i][1] = globalData[gif_index].positions[current_index][optimals[i]][0];
            }
        }

        function animate() {
            drawDrones();
            for (let i = 0; i < n; i++) {
                moveDroneTowardsTarget(i);
            }

            // Request next animation frame
            requestAnimationFrame(animate);
        }

        // Event listener for keydown events
        window.addEventListener("keydown", handleKeyDown);
    </script>
</body>

</html>